{"ast":null,"code":"import { isPresent } from './misc';\nimport { parseColor } from '@progress/kendo-drawing';\n/**\n * @hidden\n */\n\nvar ColorPaletteService =\n/** @class */\nfunction () {\n  function ColorPaletteService() {\n    this.colorRows = [];\n  }\n\n  ColorPaletteService.prototype.setColorMatrix = function (palette, columns) {\n    this.colorRows = [];\n\n    if (!(isPresent(palette) && palette.length)) {\n      return;\n    }\n\n    columns = columns || palette.length;\n\n    for (var start = 0; start < palette.length; start += columns) {\n      var row = palette.slice(start, columns + start);\n      this.colorRows.push(row);\n    }\n  };\n\n  ColorPaletteService.prototype.getCellCoordsFor = function (color) {\n    var _this = this;\n\n    if (!isPresent(color)) {\n      return;\n    }\n\n    var parsedColor = color ? parseColor(color, true) : color;\n    var colors = [color];\n\n    if (isPresent(parsedColor)) {\n      colors.push(parsedColor.toCss(), parsedColor.toCssRgba());\n    }\n\n    var _loop_1 = function (row) {\n      var _loop_2 = function (col) {\n        if (colors.some(function (c) {\n          return c === _this.colorRows[row][col];\n        })) {\n          return {\n            value: {\n              row: row,\n              col: col\n            }\n          };\n        }\n      };\n\n      for (var col = 0; col < this_1.colorRows[row].length; col++) {\n        var state_2 = _loop_2(col);\n\n        if (typeof state_2 === \"object\") return state_2;\n      }\n    };\n\n    var this_1 = this;\n\n    for (var row = 0; row < this.colorRows.length; row++) {\n      var state_1 = _loop_1(row);\n\n      if (typeof state_1 === \"object\") return state_1.value;\n    }\n  };\n\n  ColorPaletteService.prototype.getColorAt = function (cellCoords) {\n    if (!(isPresent(cellCoords) && isPresent(this.colorRows[cellCoords.row]))) {\n      return;\n    }\n\n    return this.colorRows[cellCoords.row][cellCoords.col];\n  };\n\n  ColorPaletteService.prototype.getNextCell = function (current, horizontalStep, verticalStep) {\n    if (!(isPresent(current) && isPresent(current.row) && isPresent(current.col))) {\n      return {\n        row: 0,\n        col: 0\n      };\n    }\n\n    var row = this.clampIndex(current.row + verticalStep, this.colorRows.length - 1);\n    var col = this.clampIndex(current.col + horizontalStep, this.colorRows[row].length - 1);\n    return {\n      row: row,\n      col: col\n    };\n  };\n\n  ColorPaletteService.prototype.clampIndex = function (index, max) {\n    var minArrayIndex = 0;\n\n    if (index < minArrayIndex) {\n      return minArrayIndex;\n    }\n\n    if (index > max) {\n      return max;\n    }\n\n    return index;\n  };\n\n  return ColorPaletteService;\n}();\n\nexport { ColorPaletteService };","map":null,"metadata":{},"sourceType":"module"}